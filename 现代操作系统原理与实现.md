# 现代操作系统原理与实现

## 第一章 操作系统概述

微内核和宏内核

微内核：把操作系统内最核心、最基础的功能（如进程管理、内存管理、基础的IPC）放进内核里；其它功能（驱动、文件系统、网络协议等）都移到用户态，通过消息传递机制（IPC）与内核通信。

内核态常见功能：调度器、内存管理、通信管理、权限管理

宏内核：操作系统所有核心服务都集成在单一内核空间内，包括驱动、文件系统、网络协议等。

## 第二章 硬件结构



**冯诺伊曼结构**：

- 中央处理单元：主要负责运算和逻辑控制
- 存储器：负责存储程序指令和数据，以及保存程序运行的中间结果和最终结果
- 输入输出设备：负责和外界进行交互，从外界获得输入，将结果向外界输出

### 2.1 CPU与指令集架构

#### 2.1.1 指令集

**概念：**指令集架构（ISA）是CPU和如那件之间的桥梁，指令集是ISA的重要组成部分，通常包含一系列不同工会层的指令，用于数据搬移、计算、内存访问、过程调用等。

AArch64架构是精简指令集，每条指令的长度固定为4字节，指令类型包括：

- 数据搬移指令（如mov）
- 寄存器计算指令（如加法add、减法sub）
- 内存读写指令（如内存加载指令ldr、内存写入指令str）
- 跳转指令（如无条件跳转指令b）
- 过程调用指令（如调用指令bl、返回指令ret）
- 特权指令（如读取系统寄存器指令msr、写入系统寄存器指令mrs）

#### 2.1.2 特权级

特权级，再AArch64中被称为异常级别（Exception Level，EL），一共有四种特权级：

- **EL0：**最低的特权级，应用程序一般运行在这个特权级下，也被称为**用户态**；
- **EL1：**操作系统通常运行在该特权级下，也称为**内核态**；
- **EL2：**在虚拟化场景下需要，**虚拟机监视器（Virtual Machine Monitor，VMM，也称为Hypervisor）**通常运行在该特权级下；
- **EL3：**和安全特性 `TrustZone` 相关，负责普通世界和安全世界之间切换；

一般来说，从**EL0**切换到**EL1**的可能场景有三种：

- 应用程序需要调用操作系统提供的**系统调用**，此时应用程序会通过执行svc（AArch64下，特权调用，supervisor call）指令将CPU特权级从EL0切换到EL1；
- 应用程序执行指令时，触发了**异常**，该异常导致CPU从EL0切换到EL1。比如：应用执行访存指令时，触发**缺页异常（page fault）**，从而切换到操作系统内核进行处理；
- 应用程序在执行过程中，CPU收到来自外设的**中断（interrupt）**，该中断也会导致CPU特权级从EL0切换到EL1；

EL0和EL1之间的切换流程，通常由CPU和操作系统内核协同完成。在发生特权级切换的时刻，CPU负责保存当前执行状态，以便操作系统内核在处理异常时使用并在处理结束后能够恢复应用程序的执行。CPU保存的主要状态包括：

- **触发异常的指令地址**（即当前程序计数器PC（Program Counter）），保存在ELR_EL1（异常链接寄存器，Exception Link Register）中；
- **异常原因**（即异常是由于执行svc指令还是由于访存缺页导致的），保存在ESR_EL1（异常症状寄存器，Exception Syndrome Register）中；
- CPU将**栈指针**（Stack Pointer，SP）从SP_EL0（应用程序使用的栈）切换到SP_EL1（操作系统可以通过设置这个寄存器来配置异常处理过程中使用的栈）；
- CPU还会保存一些其他状态，例如将CPU的相关状态保存在SPSR_EL1（已保存的程序状态寄存器，Saved Program Status Register）中，将引发缺页异常的地址存在FAR_EL1（错误地址寄存器，Fault Address Register）中；

操作系统可以在异常向量表中为不同的异常类型配置相应的异常处理函数，当发生特权级切换时，CPU会读取VBAR_EL1（向量基地址寄存器，Vector Base Address Register）来获取**异常向量表（exception vector table）**的基地址，然后根据异常原因调用操作系统设置的相应异常处理函数。

**supervisor call**和 **system call**的区别：

- **supervisor call**（简称 SVC 或 SWI）是 **一种机制**，并不是一种单独的”操作系统 API“。从硬件角度来说：supervisor call 是**一种 CPU 指令**，用来触发异常，进入操作系统或固件的特权模式（supervisor mode）。在不同 CPU 架构里名字不同：ARM → `SVC`（Supervisor Call）、x86 → `INT n`（软件中断）；
- **system call** (系统调用)是用户态程序向操作系统内核请求服务的方法，比如：Linux下`read()`, `write()`, `open()`, `fork()`, `execve()`方法，Windows下`NtCreateFile`, `NtReadFile`方法

总结：**system call** 是操作系统提供的接口；**supervisor call** 是 CPU 指令，用来进入内核态。system call 底层常用 supervisor call 实现。

#### 2.1.3 寄存器

在AArch64中，有31个64位通用寄存器，被命名为X0~X30。其中，X29用作**栈指针（Frame Pointer，FP）**寄存器，按照使用惯例，一般用于保存函数调用过程中栈顶的地址；X30用于**链接指针（Link Pointer，LP）**寄存器，CPU在执行函数调用指令b1时会自动把返回地址保存在其中。

各寄存器功能如下：

- **X0~X7：**用于函数的参数传递和函数的返回值，比如int add(int a, int b) {return a + b;}，在汇编层，a→X0，b→X1，返回值→X0，若参数多于 8 个，剩下的放在栈上。
- **X8：**间接结果位置寄存器（Indirect Result Location Register）。用于返回大对象地址，在某些 ABI 下，X8 用来传递系统调用号。
- **X9 - X15：**临时寄存器。函数调用时不需要被保留，被称为 caller-saved。调用者保存 (caller-saved)：如果调用者想保留它们，需要自己在栈上保存。
- **X16 - X17：**过程调用内部临时寄存器（Intra-Procedure-call scratch registers）。用于内部调用，尤其是分支跳转。通常编译器内部用，不建议在普通代码滥用。
- **X18：**平台寄存器（Platform Register），不同平台有不同用途，Windows → 保留系统线程信息，Linux → 未定义用途（留作将来用），所以在跨平台代码里尽量 **不要用 X18**。
- **X19 - X28：**被调用者保存寄存器，用于保存重要局部变量、保存长生命周期的数据，但是在函数返回前必须返回原值。
- **X29：**栈指针（Frame Pointer，FP）寄存器，按照使用惯例，一般用于保存函数调用过程中栈顶的地址。
- **X30：**用于链接指针（Link Pointer，LP）寄存器，CPU在执行函数调用指令b1时会自动把返回地址保存在其中。

在EL1特权下，有两个页面基地址寄存器（Translation Table Base Register，TTBR），即TTBR0_EL1和TTBR1_EL1，它们负责翻译虚拟地址空间中不同的地址段，负责的地址范围由另一个控制寄存器TCR_EL1（翻译控制寄存器，Translation Control Register）决定。操作系统中一种常见的配置是：

- **TTBR0_EL1：**负责[0，2<sup>48</sup>)的地址映射（作为用户地址空间）。
- **TTBR1_EL1：**负责[2<sup>48</sup>，2<sup>64</sup>)的地址映射（作为操作系统内核地址空间及保留空间）。

### 2.2 物理内存和CPU缓存

CPU使用物理内存的方式：通过总线向物理内存发送一个读写请求，其中包括目标地址（若是写请求，则还包括写入值），物理内存在收到请求后进行读写操作（若是读请求，则将读取值返回给CPU）。因此从CPU角度，可以把物理内存看作由字节组成的大数组：其中每一个字节拥有一个地址（物理地址），CPU可以在这个数组中存取数据。

#### 2.2.1 缓存结构

CPU缓存是由若干**缓存行（cache line）**组成的，每个缓存行包括：一个**有效位（valid bit）**，用于标配是其是否有效；一个**标记地址（tag address）**，用于标识其对应的物理地址；一些其他的状态信息。

物理地址在逻辑上分为**Tag**、**Set（也称为Index）**以及**Offset**三段。组（Set）和路（Way）是CPU缓存的经典概念。物理地址中的Set段能表示的最大数目称为组。同一组（即Set相等）下，支持的最大Tag数称为路，即同一组下的缓存行数目。

假如一个组内，缓存最多支持4个不同的Tag，那么该CPU缓存被称为**四路组相联（4-Way Set Associative）**。

缓存行结构：

- **Valid Bit：**表示这一行数据是否有效。
- **Tag：**用于跟物理地址里的 tag 匹配（物理地址标识）。
- **Data Block：**真正的 64 字节数据（数据行大小为64B时）。

物理地址结构：

- **Block Offset：**根据缓存行大小计算位数，比如缓存行大小为64B，2<sup>6</sup>=64，所以Block Offset为6位（低位）。
- **Set Index：**根据缓存行组数计算位数，比如缓存行一共有1024行，4路组相联，那么就有256组，2<sup>8</sup>=256，所以Set Index为8位（低位）。
- **Tag：**物理地址除去Block Offset和Set Index之外的位数，都是Tag，用于和缓存行中的Tag匹配。

#### 2.2.2 缓存寻址

假如一个CPU缓存的相关参数如下：

- 物理地址长度为44位；
- 缓存大小为32KB，缓存行大小为64字节；
- 256组，2路组相联缓存；

根据缓存行大小可知，物理地址的Offset占6位；根据缓存行组数可知，物理地址的Set占8位；已知物理地址总长度位44位，那么高30位为Tag信息。

假如物理地址为0x2fbbc030（0010 1111 1010 1010 1100 0000 0011 0000），Offset为0x30（低6位，11 0000），Set为0x0（低8位，00 0000 00），Tag为0xbeef（剩余位，1011 1110 1010 1011）。

假如要读取以物理地址0x2fbbc030开始的4字节的物理内存数据，先根据Set定位到Set=0的两个缓存行，再对比Tag并且检查Valid是否为1（标识该缓存行有效），如果有效则进一步根据Offset进行访问（Offset代表从缓存行的第几位开始读取）。

 
