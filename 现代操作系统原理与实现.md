# 现代操作系统原理与实现

## 第一章 操作系统概述

微内核和宏内核

微内核：把操作系统内最核心、最基础的功能（如进程管理、内存管理、基础的IPC）放进内核里；其它功能（驱动、文件系统、网络协议等）都移到用户态，通过消息传递机制（IPC）与内核通信。

内核态常见功能：调度器、内存管理、通信管理、权限管理

宏内核：操作系统所有核心服务都集成在单一内核空间内，包括驱动、文件系统、网络协议等。

## 第二章 硬件结构



**冯诺伊曼结构**：

- 中央处理单元：主要负责运算和逻辑控制
- 存储器：负责存储程序指令和数据，以及保存程序运行的中间结果和最终结果
- 输入输出设备：负责和外界进行交互，从外界获得输入，将结果向外界输出

### 2.1 CPU与指令集架构

#### 2.1.1 指令集

**概念：**指令集架构（ISA）是CPU和如那件之间的桥梁，指令集是ISA的重要组成部分，通常包含一系列不同工会层的指令，用于数据搬移、计算、内存访问、过程调用等。

AArch64架构是精简指令集，每条指令的长度固定为4字节，指令类型包括：

- 数据搬移指令（如mov）
- 寄存器计算指令（如加法add、减法sub）
- 内存读写指令（如内存加载指令ldr、内存写入指令str）
- 跳转指令（如无条件跳转指令b）
- 过程调用指令（如调用指令bl、返回指令ret）
- 特权指令（如读取系统寄存器指令msr、写入系统寄存器指令mrs）

#### 2.1.2 特权级

特权级，再AArch64中被称为异常级别（Exception Level，EL），一共有四种特权级：

- **EL0：**最低的特权级，应用程序一般运行在这个特权级下，也被称为**用户态**；
- **EL1：**操作系统通常运行在该特权级下，也称为**内核态**；
- **EL2：**在虚拟化场景下需要，**虚拟机监视器（Virtual Machine Monitor，VMM，也称为Hypervisor）**通常运行在该特权级下；
- **EL3：**和安全特性 `TrustZone` 相关，负责普通世界和安全世界之间切换；

一般来说，从**EL0**切换到**EL1**的可能场景有三种：

- 应用程序需要调用操作系统提供的**系统调用**，此时应用程序会通过执行svc（AArch64下，特权调用，supervisor call）指令将CPU特权级从EL0切换到EL1；
- 应用程序执行指令时，触发了**异常**，该异常导致CPU从EL0切换到EL1。比如：应用执行访存指令时，触发**缺页异常（page fault）**，从而切换到操作系统内核进行处理；
- 应用程序在执行过程中，CPU收到来自外设的**中断（interrupt）**，该中断也会导致CPU特权级从EL0切换到EL1；

EL0和EL1之间的切换流程，通常由CPU和操作系统内核协同完成。在发生特权级切换的时刻，CPU负责保存当前执行状态，以便操作系统内核在处理异常时使用并在处理结束后能够恢复应用程序的执行。CPU保存的主要状态包括：

- **触发异常的指令地址**（即当前程序计数器PC（Program Counter）），保存在ELR_EL1（异常链接寄存器，Exception Link Register）中；
- **异常原因**（即异常是由于执行svc指令还是由于访存缺页导致的），保存在ESR_EL1（异常症状寄存器，Exception Syndrome Register）中；
- CPU将**栈指针**（Stack Pointer，SP）从SP_EL0（应用程序使用的栈）切换到SP_EL1（操作系统可以通过设置这个寄存器来配置异常处理过程中使用的栈）；
- CPU还会保存一些其他状态，例如将CPU的相关状态保存在SPSR_EL1（已保存的程序状态寄存器，Saved Program Status Register）中，将引发缺页异常的地址存在FAR_EL1（错误地址寄存器，Fault Address Register）中；

操作系统可以在异常向量表中为不同的异常类型配置相应的异常处理函数，当发生特权级切换时，CPU会读取VBAR_EL1（向量基地址寄存器，Vector Base Address Register）来获取**异常向量表（exception vector table）**的基地址，然后根据异常原因调用操作系统设置的相应异常处理函数。

**supervisor call**和 **system call**的区别：

- **supervisor call**（简称 SVC 或 SWI）是 **一种机制**，并不是一种单独的”操作系统 API“。从硬件角度来说：supervisor call 是**一种 CPU 指令**，用来触发异常，进入操作系统或固件的特权模式（supervisor mode）。在不同 CPU 架构里名字不同：ARM → `SVC`（Supervisor Call）、x86 → `INT n`（软件中断）；
- **system call** (系统调用)是用户态程序向操作系统内核请求服务的方法，比如：Linux下`read()`, `write()`, `open()`, `fork()`, `execve()`方法，Windows下`NtCreateFile`, `NtReadFile`方法

总结：**system call** 是操作系统提供的接口；**supervisor call** 是 CPU 指令，用来进入内核态。system call 底层常用 supervisor call 实现。

#### 2.1.3 寄存器

在AArch64中，有31个64位通用寄存器，被命名为X0~X30。其中，X29用作**栈指针（Frame Pointer，FP）**寄存器，按照使用惯例，一般用于保存函数调用过程中栈顶的地址；X30用于**链接指针（Link Pointer，LP）**寄存器，CPU在执行函数调用指令b1时会自动把返回地址保存在其中。

各寄存器功能如下：

- **X0~X7：**用于函数的参数传递和函数的返回值，比如int add(int a, int b) {return a + b;}，在汇编层，a→X0，b→X1，返回值→X0，若参数多于 8 个，剩下的放在栈上。
- **X8：**间接结果位置寄存器（Indirect Result Location Register）。用于返回大对象地址，在某些 ABI 下，X8 用来传递系统调用号。
- **X9 - X15：**临时寄存器。函数调用时不需要被保留，被称为 caller-saved。调用者保存 (caller-saved)：如果调用者想保留它们，需要自己在栈上保存。
- **X16 - X17：**过程调用内部临时寄存器（Intra-Procedure-call scratch registers）。用于内部调用，尤其是分支跳转。通常编译器内部用，不建议在普通代码滥用。
- **X18：**平台寄存器（Platform Register），不同平台有不同用途，Windows → 保留系统线程信息，Linux → 未定义用途（留作将来用），所以在跨平台代码里尽量 **不要用 X18**。
- **X19 - X28：**被调用者保存寄存器，用于保存重要局部变量、保存长生命周期的数据，但是在函数返回前必须返回原值。
- **X29：**栈指针（Frame Pointer，FP）寄存器，按照使用惯例，一般用于保存函数调用过程中栈顶的地址。
- **X30：**用于链接指针（Link Pointer，LP）寄存器，CPU在执行函数调用指令b1时会自动把返回地址保存在其中。

在EL1特权下，有两个页面基地址寄存器（Translation Table Base Register，TTBR），即TTBR0_EL1和TTBR1_EL1，它们负责翻译虚拟地址空间中不同的地址段，负责的地址范围由另一个控制寄存器TCR_EL1（翻译控制寄存器，Translation Control Register）决定。操作系统中一种常见的配置是：

- **TTBR0_EL1：**负责[0，2<sup>48</sup>)的地址映射（作为用户地址空间）。
- **TTBR1_EL1：**负责[2<sup>48</sup>，2<sup>64</sup>)的地址映射（作为操作系统内核地址空间及保留空间）。

### 2.2 物理内存和CPU缓存

CPU使用物理内存的方式：通过总线向物理内存发送一个读写请求，其中包括目标地址（若是写请求，则还包括写入值），物理内存在收到请求后进行读写操作（若是读请求，则将读取值返回给CPU）。因此从CPU角度，可以把物理内存看作由字节组成的大数组：其中每一个字节拥有一个地址（物理地址），CPU可以在这个数组中存取数据。

#### 2.2.1 缓存结构

CPU缓存是由若干**缓存行（cache line）**组成的，每个缓存行包括：一个**有效位（valid bit）**，用于标配是其是否有效；一个**标记地址（tag address）**，用于标识其对应的物理地址；一些其他的状态信息。

物理地址在逻辑上分为**Tag**、**Set（也称为Index）**以及**Offset**三段。组（Set）和路（Way）是CPU缓存的经典概念。物理地址中的Set段能表示的最大数目称为组。同一组（即Set相等）下，支持的最大Tag数称为路，即同一组下的缓存行数目。

假如一个组内，缓存最多支持4个不同的Tag，那么该CPU缓存被称为**四路组相联（4-Way Set Associative）**。

缓存行结构：

- **Valid Bit：**表示这一行数据是否有效。
- **Tag：**用于跟物理地址里的 tag 匹配（物理地址标识）。
- **Data Block：**真正的 64 字节数据（数据行大小为64B时）。

物理地址结构：

- **Block Offset：**根据缓存行大小计算位数，比如缓存行大小为64B，2<sup>6</sup>=64，所以Block Offset为6位（低位）。
- **Set Index：**根据缓存行组数计算位数，比如缓存行一共有1024行，4路组相联，那么就有256组，2<sup>8</sup>=256，所以Set Index为8位（低位）。
- **Tag：**物理地址除去Block Offset和Set Index之外的位数，都是Tag，用于和缓存行中的Tag匹配。

#### 2.2.2 缓存寻址

假如一个CPU缓存的相关参数如下：

- 物理地址长度为44位；
- 缓存大小为32KB，缓存行大小为64字节；
- 256组，2路组相联缓存；

根据缓存行大小可知，物理地址的Offset占6位；根据缓存行组数可知，物理地址的Set占8位；已知物理地址总长度位44位，那么高30位为Tag信息。

假如物理地址为0x2fbbc030（0010 1111 1010 1010 1100 0000 0011 0000），Offset为0x30（低6位，11 0000），Set为0x0（低8位，00 0000 00），Tag为 0xbeef（剩余位，1011 1110 1010 1011）。

假如要读取以物理地址0x2fbbc030开始的4字节的物理内存数据，先根据Set定位到Set=0的两个缓存行，再对比Tag并且检查Valid是否为1（标识该缓存行有效），如果有效则进一步根据Offset进行访问（Offset代表从缓存行的第几位开始读取）。

###  2.3 设备与中断

#### 2.3.1 内存映射输入输出

**内存映射输入输出（Memory-Mapped I/O，MMIO）**是一种常见的CPU控制和访问设备的方式。原理是：把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配相应的地址。当CPU通过MMIO的方式为一个设备分配了地址之后，CPU可以使用和访问物理内存一样的指令（ldr和str）去读写这些属于设备的地址；设备通过总线监听CPU分配给自己的地址，然后完成相应的CPU访问请求。

#### 2.3.2 轮询和中断

CPU通过访问MMIO配置的地址可以获取输入，但是CPU如何才能知道输入事件的发生？

- **轮询：**让CPU不断去通过MMIO查看异步收发传输器（Universal Asynchronous Receiver/Transmitter，UART）是否有输入；
- **中断**：设备通过向CPU发出中断来打断CPU的执行，使得CPU去处理这个中断。

## 第三章 操作系统结构

合理的对操作系统的功能和架构进行设计，是一个操作系统成功的关键。操作系统需要满足一定的设计目标，这些目标可以分为以下两种：

- **用户目标：**方便使用、容易学习、可靠、安全以及流畅等；
- **系统目标：**易于实现与维护、灵活、可靠、不易出错、高效等；

通常，操作系统的设计需要在用户目标和系统目标之间进行权衡。

### 3.1 操作系统的机制与策略

操作系统乃至计算机系统中控制复杂度的一个重要设计原则是：将策略和机制相分离。策略（policy）标识要”做什么“，机制（mechanism）表示该”如何做“。

- **机制：**支持某个功能的基础手段，是能力和接口；
- **策略：**控制该功能的行为和参数，是决策行为和行为方式；

**举例：**空调可以制冷、制热、吹风，这个属于机制；空调温度设置为26°还是23°，模式是制热还是制冷，这个属于策略。

### 3.2 操作系统复杂度管理方法

管理复杂系统的重要方法是**M.A.L.H**方法，即**模块化**（modularity）、**抽象**（abstraction）、**分层**（layering）和**层级**（hierarchy）。

- **模块化：**通过”分而治之“原则，将一个复杂系统分解为一系列通过明确定义的接口进行交互的模块，并严格保证模块之间的界限。模块的划分要充分考虑**高内聚**和**低耦合**，使模块具有独立性。比如操作系统的进程管理、内存管理、网络协议栈、设备驱动等。
- **抽象：**抽象是在模块化的基础上，将接口和内部实现分离，从而使模块之间只需通过抽象的接口进行互相调用，而无需关心各个模块的内部实现。一个好的抽象应该尽可能依从模块间的自然边界，并尽可能的减少模块间的交互，从而减少错误在模块间的传递。
- **分层：**分层是通过将模块按照一定的原则进行层级的划分，约束每层内部模块间的交互方式与跨层级模块间的交互方式，从而有效减少模块之间的交互。通常一个模块只能与同层模块以及相邻的上层或下层模块进行交互，而不能跨一层和再上一层或者再下一层的模块进行交互。
- **层级：** 将一些功能相近的模块组成一个具有清晰接口的自包含子系统，然后再将这些子系统递归地组成一个具有清晰接口的更大子系统。                                                                                                                                                                                                                                                                                                                                          

**严进宽出原则：**一个模块的接口应该容忍各种可能的输入，抑制错误甚至恶意的输入，避免错误或恶意输入的效果在模块内传播，并且尽可能严格地控制模块对外的输出，从而减少错误在模块间的传播。

### 3.3 操作系统内核架构

操作系统常见内核架构：**简要结构、宏内核、微内核、外核、多内核等**。

#### 3.3.1 简要结构

将应用程序和操作系统放置在同一个地址空间（address space）中，无需底层硬件提供复杂的内存管理、特权级隔离等功能。

MS-DOS（MicroSoft Disk Operating System）是采用了简要结构的一个典型例子。除了MS-DOS外，当前采用简要结构的操作系统还包括FreeRTOS和uCOS等。

- **优点：**应用程序对操作系统服务的调用可直接通过函数调用高效完成。
- **缺点：**任何一个应用或操作系统模块出现了问题，均有可能使整个系统崩溃。

简要结构的操作系统主要运行在**微控制单元（MicroController Unit，MCU）**等相对比较简单的硬件上，这些硬件通常没有提供现代意义上的**内存管理单元（Memory Management Unit，MMU）**，隔离能力较弱或缺失，难以运行复杂的操作系统。
